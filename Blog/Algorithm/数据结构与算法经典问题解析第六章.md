# 树

数是一种典型的非线性的数据存储结构，与链表类似，但却不同，因为树的一个节点可以指向多个节点。

- 部分术语
  - 叶子结点：没有孩子节点的节点叫做叶子节点
  - 节点的深度：从根节点到该节点的路径长度
  - 节点的高度：是指从该结点到最深结点的路径长度
  - 斜树：如果树中除了叶子节点外，其余每一节点只有一个孩子节点，这种树称作斜树。



## 二叉树

一棵树中每个节点只有0，1或2个孩子节点，那么这棵树称为**二叉树**。

- 类型

  - 严格二叉树：每个节点要么有两个孩子节点，要么没有孩子节点

    ![](./shu1.png)    

  - 满二叉树：二叉树中每个结点恰好有两个孩子结点且所有叶子结点都在同一层

    ![](./shu2.png)

    

  - 完全二叉树：假定二叉树的高度为h，所有结点从根节点开始从左到右，从上之下，依次编号，那么将得到1到n的完整序列。所有叶子节点的深度为h或h-1，且在结点编号序列中没有漏电任何数字，这样的二叉树称为完全二叉树。

    ![](./shu3.png)

- 性质

  - 满二叉树的结点个数n为2^(h+1)-1
  - 完全二叉树的结点个数为2^h ~ 2^(h+1)-1
  - 满二叉树的叶子节点个数是2^h
  - 对于n个结点的完全二叉树，空指针的个数为n+1

- 结构

  定义两个指针，分别指向左右子树

  ```java
  public class BinaryTreeNode{
      private int data;
      private BinaryTreeNode left;
      private BinaryTreeNode right;
      //getter，setter方法
      //......
  }
  ```

- 应用

  - 编译器中表达式树
  - 用于数据压缩算法中赫夫曼编码树
  - 支持在集合中查找，插入和删除，其平均时间复杂度为O(logn)的二叉搜索树
  - 优先队列（PQ）支持以对数时间（最坏情况下）对集合中的最小（或最大）数据元素进行搜索和遍历

- 遍历

  - 前序遍历：先遍历当前结点，然后遍历左子树，最后遍历右子树
  - 中序遍历：首先遍历左子树，再访问当前结点，最后遍历右子树
  - 后续遍历：首先遍历左子树，再遍历右子树，最后访问当前结点
  - 层序遍历：按层遍历，这是一种广度优先遍历方法

### 遍历实现

#### 前序遍历

```java
//递归版本,时间复杂度为O(n),空间复杂度为O(n)
void PreOrder(BinaryTreeNode root) {
    if(root != null) {
        System.out.println(root.getData());
        PreOrder(root.getLeft());
        PreOrder(root.getRight());
    }
}
//非递归版本,时间复杂度为O(n),空间复杂度为O(n)
//采用一个栈进行记录
void PreOrderNonRecursive(BinaryTreeNode root) {
    if(root == null) return null;
    LLStack S = new LLStack();
    while(true) {
        while(root!=null) {
            System.out.println(root.getData);
            S.push(root);
            root = root.left;//遍历左子树
        }
        if(S.isEmpty()) break;
        root = (BinaryTreeNode)S.pop();
        root = root.getRight();
    }
    return;
}
```

#### 中序遍历

```java
//递归版本
void InOrder(BinaryTreeNode root) {
    if(root != null) {
        InOrder(root.getLeft());
        System.out.println(root.getData());
        InOrder(root.getRight());
    }
}
//非递归版本
void InOrderNonRecursive(BinaryTreeNode root) {
    if(root == null) return null;
    LLStack S = new LLStack();
    while(true) {
        while(root != null) {
            S.push(root);
            root = root.getLeft();
        }
        if(S.isEmpty()) break;
        root = (BinaryTreeNode)S.pop();
        System.out.println(root.getData());
        root = root.getRight();
    }
    return;
}
```

#### 后序遍历

```java
void PostOrder(BinaryTreeNode root) {
    if(root != null) {
        PostOrder(root.getLeft());
        PostOrder(root.getRight());
        System.out.println(root.getData());
    }
}

//非递归版本
//后序遍历的非递归版本：要解决当前结点要被访问两遍
void PostOrderNonRecursive(BinaryTreeNode root) {
    LLStack S = new LLStack();
    while(1) {
        if(root!=null) {
            S.push(root);
            root = root.getLeft();
        } else {
            if(S.isEmpty()) {
                System.out.println("Stack is Empty");
                return;
            } else {
                if(S.top().getRight() == null) {
                    //右子树不存在时
                    root = S.pop();
                    System.out.println(root.getData());
                    if(root == S.top().getRight()) {
                        System.out.println(S.top().getData());
                        s.pop();
                    }
                }
                if(!S.isEmpty()) root = S.top().getRight();
                else root = null;
            }
        }
    }
}
```

## 问题

对于树的问题，一般可以通过递归方法解决，采取非递归方法，可以采用队列存储元素。时间复杂度和空间复杂度均为O(n)。



1. 删除树？

   删除树一般采取后序遍历的方法，先删除孩子结点，再删除双亲结点。

   ```java
   void DeleteBinaryTree(BinaryTreeNode root) {
       if(root == null) return;
       DeleteBinaryTree(root.getLeft());
       DeleteBinaryTree(root.getRight());
       root = null;//置为null，GC会对其进行清理
   }
   ```

2. 逐层输出树中的元素，如下图所示，输出应为4 5 6 7 2 3 1

   ![](./shu2.png)

   解题思路：借助队列可以遍历每一层元素，通过栈可以输出每一层（从下往上）的元素

   ```java
   void LevelOrderTraversalInreverse(BinaryTreeNode root) {
       LLQueue Q = new LLQueue();
       LLStack S = new LLStack();
       BinaryTreeNode temp;
       if(root == null) return;
       Q.enQueue(root);
       while(!Q.isEmpty()) {
           temp = Q.deQueue();
           if(temp.getRight()) {
               Q.enQueue(temp.getRight());
           }
           if(temp.getLeft()) {
               Q.enQueue(temp.getLeft());
           }
           S.push(temp);
       }
       while(!S.isEmpty()) {
           System.out.println(S.pop().getData());
       }
   }
   ```

   