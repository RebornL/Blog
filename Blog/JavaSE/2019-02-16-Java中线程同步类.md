---
layout:     post
title:      Java中线程同步类
subtitle:   
date:       2019-02-16
author:     Reborn
header-img: img/post-bg-universe.jpg
catalog: true
tags:
    - Java
---

# Java中线程同步类

## CountDownLatch类

CountDownLatch类，是用来线程同步辅助类，可用在某些线程工作前先完成某些动作或这某些线程工作完成后进行收尾工作。

主要的两个方法：

- countDown()：使计数器减一
- await()：当count为0时，等待的线程会被释放可以进行下一步操作



简单使用：

例如：有三个线程在进行爬取内容，有一个线程进行汇总。

```java
public class CountDownLatchTest {
    public static void main(String[] args) {
        CountDownLatch cdl = new CountDownLatch(3);
        new Thread(new Runable() {
            @Override
            public void run() {
                try {
                    // 这里调用的是await()不是wait()
                    countDownLatch.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println("汇总所有爬取的内容");
            }
        }).start();
        
        for(int i = 0; i < 3; i++) {
            new Thread(new Runable() {
                @Override
                public void run() {
                    System.out.println("正在爬取第"+i+"个页面");
                    cdl.countDown();                
                }
            }).start();
        }
    }
}
```



## CyclicBarrier类

CyclicBarrier允许一组线程相互等待，直至到了公共屏障点，这组线程才可以继续执行下去。而且CycliBarrier可以被重用。



```java
public class CyclicBarrierTest {
    // 参与者数量
    private static int parties = 3;
    // 创建一个新的 CyclicBarrier，它将在给定数量的参与者（线程）处于等待状态时启动
    private static CyclicBarrier barrier = new CyclicBarrier(parties);
    public static void main(String[] args) throws InterruptedException {
        for (int i = 0; i < parties; i++)
            new Thread(new Task()).start();
        Thread.sleep(1000);
        System.out.println("getNumberWaiting()：" + barrier.getNumberWaiting());
    }

    static class Task implements Runnable {
        public void run() {
            try {
                System.out.println(Thread.currentThread().getName() + "await");
                // 在所有参与者都已经在此 barrier 上调用 await 方法之前，将一直等待。
                barrier.await();
                System.out.println(Thread.currentThread().getName() + "continued");
            } catch (BrokenBarrierException e) {
                e.printStackTrace();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
```



## Semaphore

Semaphore，其实就是信号量，内部保留一个计数count，用于控制同时访问线程个数。

主要两个方法：

- acquire()：获取信号量，得到之后count减一，可以继续执行；否则会阻塞起来
- release()：操作完成，需要释放信号量，count加1



举例：

银行有三个窗口，每次最多只能有三个人去办理业务。

```java
public class SemaphoreTest {
    public static void main(String[] args) {
        int num = 10;
        Semaphore semaphore = new Semaphore(3);
        for(int i = 0; i < num; i++) {
            final int person = i;
            new Thread(new Runnable() {
                @Override
                public void run() {
                    try {
                        semaphore.acquire();
                        System.out.println("第"+(person+1)+"位正在前台办理业务");
                        Thread.sleep(1000);
                        System.out.println("第"+person+"位办理完业务");
                        semaphore.release();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }).start();

            Thread.sleep(10);
        }
    }
}
```

